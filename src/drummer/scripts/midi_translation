#!/usr/bin/env python3
from re import I
from turtle import pos
from mido import MidiFile
import os
import sys

from matplotlib import pyplot as plt
from matplotlib import patches
from matplotlib import colors
import pretty_midi

from time import sleep
import time

# ROS imports
import rospy
import tf2_ros
import tf2_geometry_msgs
from geometry_msgs.msg import PoseStamped,Pose

# Robot interface
import actionlib
from control_msgs.msg import FollowJointTrajectoryAction, FollowJointTrajectoryGoal
from trajectory_msgs.msg import JointTrajectoryPoint
from controller_manager_msgs.srv import SwitchControllerRequest, SwitchController
from controller_manager_msgs.srv import LoadControllerRequest, LoadController
import geometry_msgs.msg as geometry_msgs
from cartesian_control_msgs.msg import (
    FollowCartesianTrajectoryAction,
    FollowCartesianTrajectoryGoal,
    CartesianTrajectoryPoint,
)

# creating dictionary for translation of number of note to name of instrument
instruments_dictionary = {
35: 'Bass Drum 2',
36: 'Bass Drum 1',
37: 'Side Stick',
38: 'Snare Drum 1',
39: 'Hand Clap',
40: 'Snare Drum 2',
41: 'Low Tom 2',
42: 'Closed Hi-hat',
43: 'Low Tom 1',
44: 'Pedal Hi-hat',
45: 'Mid Tom 2',
46: 'Open Hi-hat',
47: 'Mid Tom 1',
48: 'High Tom 2',
49: 'Crash Cymbal 1',
50: 'High Tom 1',
51: 'Ride Cymbal 1',
52: 'Chinese Cymbal',
53: 'Ride Bell',
54: 'Tambourine',
55: 'Splash Cymbal',
56: 'Cowbell',
57: 'Crash Cymbal 2',
58: 'Vibra Slap',

59: 'Ride Cymbal 2',
60: 'High Bongo',
61: 'Low Bongo',
62: 'Mute High Conga',
63: 'Open High Conga',
64: 'Low Conga',
65: 'High Timbale',
66: 'Low Timbale',
67: 'High Agogo',
68: 'Low Agogo',
69: 'Cabasa',
70: 'Maracas',
71: 'Short Whistle',
72: 'Long Whistle',
73: 'Short Guiro',
74: 'Long Guiro',
75: 'Claves',
76: 'High Wood Block',
77: 'Low Wood Block',
78: 'Mute Cuica',
79: 'Open Cuica',
80: 'Mute Triangle',
81: 'Open Triangle' }

# printing name and type, aswell as numbers of tracks and messages of file
file_name = 'AC_DC_-_Highway_to_hell.mid'
SCRIPTDIR = os.path.dirname(__file__)

class TrajectoryClient:
    """Small trajectory client to test a joint trajectory"""

    # All of those controllers can be used to execute joint-based trajectories.
    # The scaled versions should be preferred over the non-scaled versions.
    JOINT_TRAJECTORY_CONTROLLERS = [
        "scaled_pos_joint_traj_controller",
        "scaled_vel_joint_traj_controller",
        "pos_joint_traj_controller",
        "vel_joint_traj_controller",
        "forward_joint_traj_controller",
    ]

    # All of those controllers can be used to execute Cartesian trajectories.
    # The scaled versions should be preferred over the non-scaled versions.
    CARTESIAN_TRAJECTORY_CONTROLLERS = [
        "pose_based_cartesian_traj_controller",
        "joint_based_cartesian_traj_controller",
        "forward_cartesian_traj_controller",
    ]

    # We'll have to make sure that none of these controllers are running, as they will
    # be conflicting with the joint trajectory controllers
    CONFLICTING_CONTROLLERS = ["joint_group_vel_controller", "twist_controller"]

    def __init__(self):
        rospy.init_node("test_move")

        timeout = rospy.Duration(5)
        self.switch_srv = rospy.ServiceProxy(
            "controller_manager/switch_controller", SwitchController
        )
        self.load_srv = rospy.ServiceProxy("controller_manager/load_controller", LoadController)
        try:
            self.switch_srv.wait_for_service(timeout.to_sec())
        except rospy.exceptions.ROSException as err:
            rospy.logerr("Could not reach controller switch service. Msg: {}".format(err))
            sys.exit(-1)

        self.cartesian_trajectory_controller = self.CARTESIAN_TRAJECTORY_CONTROLLERS[0]

    def send_cartesian_trajectory(self, poses: list[Pose], timestamps: list[float]):
        """Creates a Cartesian trajectory and sends it using the selected action server"""
        self.switch_controller(self.cartesian_trajectory_controller)

        # make sure the correct controller is loaded and activated
        goal = FollowCartesianTrajectoryGoal()
        trajectory_client = actionlib.SimpleActionClient(
            "{}/follow_cartesian_trajectory".format(self.cartesian_trajectory_controller),
            FollowCartesianTrajectoryAction,
        )

        assert len(poses) == len(timestamps)
        for i, pose in enumerate(poses):
            point = CartesianTrajectoryPoint()
            point.pose = pose
            point.time_from_start = rospy.Duration(timestamps[i])
            goal.trajectory.points.append(point)

        rospy.loginfo(
            "Executing trajectory using the {}".format(self.cartesian_trajectory_controller)
        )
        trajectory_client.send_goal(goal)
        trajectory_client.wait_for_result()

        result = trajectory_client.get_result()

        rospy.loginfo("Trajectory execution finished in state {}".format(result.error_code))

    def switch_controller(self, target_controller):
        """Activates the desired controller and stops all others from the predefined list above"""
        other_controllers = (
            self.JOINT_TRAJECTORY_CONTROLLERS
            + self.CARTESIAN_TRAJECTORY_CONTROLLERS
            + self.CONFLICTING_CONTROLLERS
        )

        other_controllers.remove(target_controller)

        srv = LoadControllerRequest()
        srv.name = target_controller
        self.load_srv(srv)

        srv = SwitchControllerRequest()
        srv.stop_controllers = other_controllers
        srv.start_controllers = [target_controller]
        srv.strictness = SwitchControllerRequest.BEST_EFFORT
        self.switch_srv(srv)



if __name__ == '__main__':
    rospy.init_node('midi_translation')

    ##### Step 1: Load the Midi File #####

    t_client = TrajectoryClient()
    mid = MidiFile(os.path.join(SCRIPTDIR, '..', 'MIDI', 'samples', file_name), clip=True) 

    # removing duplicates of tracks
    message_numbers = []
    duplicates = []

    for track in mid.tracks:                    # searching track by track in MIDI file
        if len(track) in message_numbers:       # if number of messages in a track equals number of messages from a previous track
            duplicates.append(track)            # then add to duplicates
        else:
            message_numbers.append(len(track))

    for track in duplicates:                    # remove the duplicates
        mid.tracks.remove(track)


    wrong_tracks = []
    # finding the track of the drums in MIDI files via channel    
    for track in mid.tracks:                  # going through the tracks of the file
        for msg in track:                                   # going through the messages in each track
            if not msg.is_meta and (msg.channel != 9):      # checking non-meta messages and looking for the messages with channel = 9
                wrong_tracks.append(track)
                break

    for track in wrong_tracks:
        mid.tracks.remove(track)

    new_file_name = 'drums_only_{}'.format(file_name)
    mid.save('.\\MIDI\\samples\\{}'.format(new_file_name))


    ##### Source: https://www.audiolabs-erlangen.de/resources/MIR/FMP/C1/C1S2_MIDI.html #####

    midi_data = pretty_midi.PrettyMIDI('.\\MIDI\\samples\\{}'.format(new_file_name))
    midi_list = []

    # creating a list with the information about start, end, pitch, velocity and name of instrument of every 'note' (part of the drums) of the instrument
    for instrument in midi_data.instruments:
        for note in instrument.notes:
            start = note.start
            end = note.end
            pitch = note.pitch
            velocity = note.velocity
            midi_list.append([start, end, pitch, velocity, instrument.name])
            
    midi_list = sorted(midi_list, key=lambda x: (x[0], x[2]))

    ##### Step 2: Iterate through all midi notes and publish target poses #####

    # printing the name of the 'note' of the instrument in the moment it is actually played
    stamp = time.time()
    last_time = midi_list[0][0]

    tf_buffer = tf2_ros.Buffer()
    tf_listener = tf2_ros.TransformListener(tf_buffer)

    drum_publisher = rospy.Publisher('hit', PoseStamped, tcp_nodelay=True, queue_size=100)

    poses = []
    timestamps = []
    for k, line in enumerate(midi_list):
        if rospy.is_shutdown():
            break

        start, end, pitch, velocity, instrument = line
        component_name = instruments_dictionary[pitch]

        ##### Part 1: Finding the target pose #####
        target_pose = PoseStamped()
        target_pose.header.frame_id = component_name
        target_pose.header.stamp = rospy.Time.now()
        target_pose.pose.position.x = 0
        target_pose.pose.position.y = 0
        target_pose.pose.position.z = 0.2
        target_pose.pose.orientation.x = 1
        target_pose.pose.orientation.y = 0
        target_pose.pose.orientation.z = 0
        target_pose.pose.orientation.w = 1

        try:
            trans = tf_buffer.lookup_transform('base', component_name, rospy.Time(0))
            target_pose = tf2_geometry_msgs.do_transform_pose(target_pose, trans)
        except (tf2_ros.LookupException, tf2_ros.ConnectivityException, tf2_ros.ExtrapolationException) as e:
            rospy.logerr(f'Cannot find {component_name}: {e}')

        ##### Part 2: Timing of the hit #####
        hit_time = midi_list[k][0]

        ##### Part 3: fill the trajectory #####
        poses.append(target_pose)
        timestamps.append(hit_time)

    # Start playing by sending the trajectory to the robot
    t_client.send_cartesian_trajectory(poses=poses, timestamps=timestamps)



